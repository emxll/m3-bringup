
.globl _start
.type _start, @function
_start:

# set up stack and pray for no overflow
adrp x2, stack_top
add x2, x2, :lo12:stack_top

mov sp, x2

start_with_stack:

# save context
adrp x2, kernel_data
add x2, x2, :lo12:kernel_data

stp lr, x0, [x2]

mov x0, x1
bl set_output_buffer


adr x0, string_banner
bl puts


bl main


hook_exit:

# restore context
adrp x2, kernel_data
add x2, x2, :lo12:kernel_data

ldp lr, x0, [x2]

# unsetup stack
movz x1, #0
mov sp, x1

br lr

string_banner:
.asciz "output generated by hook:\n"




# general main function
# no args

.align 2
main:

str lr, [sp, #-0x10]!

bl el_dump

ldr lr, [sp], #0x10

br lr




# dump exception level info
# no args

.align 2
el_dump:

stp lr, x0, [sp, #-0x10]!

adr x0, string_reg0
bl puts

mrs x0, CurrentEL
bl hex_num

adr x0, string_reg1
bl puts

mrs x0, VBAR_EL1
bl hex_num

adr x0, string_reg2
bl puts

mrs x0, VBAR_EL2
bl hex_num

mov x0, 0x0a
bl putc

ldp lr, x0, [sp], #0x10

br lr

string_reg0:
.asciz "CurrentEL: "

string_reg1:
.asciz "\nVBAR_EL1: "

string_reg2:
.asciz "\nVBAR_EL2: "

# args: 
# x0 (q): number to print as hex

.align 2
hex_num:

stp lr, x1, [sp, #-0x10]!
stp x2, x3, [sp, #-0x10]!
str x4, [sp, #-0x10]!

# value
mov x4, x0

# counter
movz x2, 0x10

adrp x3, hex_alphabet
add x3, x3, :lo12:hex_alphabet

hex_num_loop:

# bits to shift value by
sub x1, x2, #1
lsl x1, x1, #2

# shift value and mask
lsr x1, x4, x1
and x1, x1, #0xf

# load character and print
ldrb w0, [x3, x1]

bl putc

subs x2, x2, #1
cbnz x2, hex_num_loop

ldr x4, [sp], #0x10
ldp x2, x3, [sp], #0x10
ldp lr, x1, [sp], #0x10

br lr

# args:
# x0 (q): pointer to string
puts:

stp lr, x1, [sp, #-0x10]!

mov x1, x0

puts_loop:

# load byte
ldrb w0, [x1], #1
and x0, x0, #0xff

# exit if null byte
cbz x0, puts_exit

# print otherwise
bl putc

b puts_loop


puts_exit:
ldp lr, x1, [sp], #0x10

br lr


# args: 
# x0 (b): char to write
putc:

stp x1, x2, [sp, #-0x10]!

adrp x1, output_buffer
add x1, x1, :lo12:output_buffer

ldr x2, [x1]
# debug:
# mov x2, x26

strb w0, [x2], #1


str x2, [x1]
# debug:
# mov x26, x2

ldp x1, x2, [sp], #0x10

br lr


set_output_buffer:

str x1, [sp, #-0x10]!

adrp x1, output_buffer
add x1, x1, :lo12:output_buffer

str x0, [x1]

ldr x1, [sp], #0x10

br lr


.align 3

output_buffer:
.quad 0

.align 4
kernel_data:
.quad 0
.quad 0

hex_alphabet:
.ascii "0123456789abcdef"


.align 4
stack_bottom:

# 8 pages
.rept   0x1000
.quad   0
.endr

stack_top: